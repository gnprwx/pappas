---
title: "TS, React, Vite"
description: "All in days work"
pubDate: "Nov 01 2023"
---

import { MDX } from "../../styles/style";

<div class={MDX}>
## Typescript

I spent Monday morning working on my Typescript repository, which is chock-full of typescript examples and use cases. I did notice that a lot of what Typescript can do is for very specialized situations. Despite this, I cherry-picked what I could see myself utilizing often: a variety of interfaces, custom types, and generics. Compared to setting a type on everything - what I'm most comfortable with - it's worth being uncomfortable for the efficiency and reduced verbosity of those options.

From there, I started converting JavaScript files into Typescript, learning and asking questions on utilizing types better as I went through the file. I found myself instinctively hunting down 'any' types and setting them to something specific, letting the action cascade down until I didn't have to do any more typesetting so inference could do the rest.

## React

I spent last night reading the React documentation and re-reading React's Thinking in React article to reinforce my understanding. I then did their Tic-Tac-Toe tutorial, where **props** and **useState** became very clear to me in their usage. That was perhaps the most significant portion of the entire tutorial because it demonstrated how versatile React is. I was impressed and can see why it is so popular.

Today I transplanted an Express API I wrote for a group project that recently switched from HTML and JavaScript to React and Vite. I decided I better go ahead and learn how to write a GET request with React on my Express server, which was unknown to me at the time. So, after a couple of hours of reading and watching videos, I had my database entries mapped out to the React front end.

For one, I needed to have both Vite and Express run on different ports in my developer environment so React could communicate with the server for data. I incorporated express CORS, removed express static, and specified the port in the fetch statement. There was another option I saw with using an alias in the vite.config file while in dev mode.

With the backend ready to go, I created a component with the fetch statement. That's when I learned about **useEffect**. With useEffect and useState, we get the same functionality we'd expect in JavaScript in fetching data, but with the ability to automatically re-render that portion of the DOM as needed.

**EDIT NOV 11 2023**: I learned you can break out the async function in this circumstance. However, in some cases, it is apparently recommended to use **useCallback async** instead of an async function. What is the deciding factor in that is something I am still learning. This can also be done using a reducer, which is not something I have any real experience with yet.

## Vite

I read some of the documentation on Vite, and it appears to be a lot more efficient than Webpack, which is what I'm used to. I'm excited to see its magic in development and production.

Overall, this week has been pretty intense with learning concepts, using new libraries, and writing safer code. Despite only being halfway through the week, I'd say it's been one of the most rewarding so far.

</div>
